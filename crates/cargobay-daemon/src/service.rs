use cargobay_core::hypervisor::{Hypervisor, HypervisorError, SharedDirectory, VmConfig, VmState};
use cargobay_core::proto;
use cargobay_core::proto::vm_service_server::VmService;
use std::sync::Arc;
use tonic::{Request, Response, Status};

#[derive(Clone)]
pub struct VmServiceImpl {
    hv: Arc<dyn Hypervisor>,
}

impl VmServiceImpl {
    pub fn new(hv: Arc<dyn Hypervisor>) -> Self {
        Self { hv }
    }

    fn status_from_error(op: &'static str, err: HypervisorError) -> Status {
        if matches!(&err, HypervisorError::NotFound(_)) {
            tracing::warn!(op = op, error = %err, "hypervisor operation failed");
        } else {
            tracing::error!(op = op, error = %err, "hypervisor operation failed");
        }

        match err {
            HypervisorError::NotFound(id) => Status::not_found(format!("VM not found: {}", id)),
            HypervisorError::Unsupported => Status::unimplemented("unsupported platform"),
            HypervisorError::RosettaUnavailable(msg) => Status::failed_precondition(msg),
            HypervisorError::VirtioFsError(msg) => Status::failed_precondition(msg),
            HypervisorError::CreateFailed(msg) => Status::failed_precondition(msg),
            HypervisorError::Storage(msg) => Status::internal(format!("storage error: {}", msg)),
            HypervisorError::Io(e) => Status::internal(format!("io error: {}", e)),
        }
    }

    fn vm_state_to_string(state: VmState) -> String {
        match state {
            VmState::Running => "running".into(),
            VmState::Stopped => "stopped".into(),
            VmState::Creating => "creating".into(),
        }
    }

    fn proto_shared_dir(dir: SharedDirectory) -> proto::SharedDirectory {
        proto::SharedDirectory {
            tag: dir.tag,
            host_path: dir.host_path,
            guest_path: dir.guest_path,
            read_only: dir.read_only,
        }
    }

    fn core_shared_dir(dir: proto::SharedDirectory) -> SharedDirectory {
        SharedDirectory {
            tag: dir.tag,
            host_path: dir.host_path,
            guest_path: dir.guest_path,
            read_only: dir.read_only,
        }
    }

    #[allow(clippy::result_large_err)]
    fn resolve_vm_id(&self, selector: &str) -> Result<String, Status> {
        let vms = self
            .hv
            .list_vms()
            .map_err(|e| Self::status_from_error("list_vms", e))?;

        if vms.iter().any(|vm| vm.id == selector) {
            return Ok(selector.to_string());
        }

        if let Some(vm) = vms.into_iter().find(|vm| vm.name == selector) {
            return Ok(vm.id);
        }

        Err(Status::not_found(format!("VM not found: {}", selector)))
    }
}

#[tonic::async_trait]
impl VmService for VmServiceImpl {
    async fn create_vm(
        &self,
        request: Request<proto::CreateVmRequest>,
    ) -> Result<Response<proto::CreateVmResponse>, Status> {
        let req = request.into_inner();
        let shared_dirs = req
            .shared_dirs
            .into_iter()
            .map(Self::core_shared_dir)
            .collect::<Vec<_>>();

        let config = VmConfig {
            name: req.name,
            cpus: req.cpus,
            memory_mb: req.memory_mb,
            disk_gb: req.disk_gb,
            rosetta: req.rosetta,
            shared_dirs,
        };

        let vm_id = self
            .hv
            .create_vm(config)
            .map_err(|e| Self::status_from_error("create_vm", e))?;
        Ok(Response::new(proto::CreateVmResponse { vm_id }))
    }

    async fn start_vm(
        &self,
        request: Request<proto::StartVmRequest>,
    ) -> Result<Response<proto::StartVmResponse>, Status> {
        let req = request.into_inner();
        let vm_id = self.resolve_vm_id(&req.vm_id)?;
        self.hv
            .start_vm(&vm_id)
            .map_err(|e| Self::status_from_error("start_vm", e))?;
        Ok(Response::new(proto::StartVmResponse {}))
    }

    async fn stop_vm(
        &self,
        request: Request<proto::StopVmRequest>,
    ) -> Result<Response<proto::StopVmResponse>, Status> {
        let req = request.into_inner();
        let vm_id = self.resolve_vm_id(&req.vm_id)?;
        self.hv
            .stop_vm(&vm_id)
            .map_err(|e| Self::status_from_error("stop_vm", e))?;
        Ok(Response::new(proto::StopVmResponse {}))
    }

    async fn delete_vm(
        &self,
        request: Request<proto::DeleteVmRequest>,
    ) -> Result<Response<proto::DeleteVmResponse>, Status> {
        let req = request.into_inner();
        let vm_id = self.resolve_vm_id(&req.vm_id)?;
        self.hv
            .delete_vm(&vm_id)
            .map_err(|e| Self::status_from_error("delete_vm", e))?;
        Ok(Response::new(proto::DeleteVmResponse {}))
    }

    async fn list_v_ms(
        &self,
        _request: Request<proto::ListVMsRequest>,
    ) -> Result<Response<proto::ListVMsResponse>, Status> {
        let vms = self
            .hv
            .list_vms()
            .map_err(|e| Self::status_from_error("list_vms", e))?;
        let out = vms
            .into_iter()
            .map(|vm| proto::VmInfo {
                vm_id: vm.id,
                name: vm.name,
                status: Self::vm_state_to_string(vm.state),
                cpus: vm.cpus,
                memory_mb: vm.memory_mb,
                rosetta_enabled: vm.rosetta_enabled,
                shared_dirs: vm
                    .shared_dirs
                    .into_iter()
                    .map(Self::proto_shared_dir)
                    .collect(),
                disk_gb: vm.disk_gb,
            })
            .collect::<Vec<_>>();

        Ok(Response::new(proto::ListVMsResponse { vms: out }))
    }

    async fn get_vm_status(
        &self,
        request: Request<proto::GetVmStatusRequest>,
    ) -> Result<Response<proto::GetVmStatusResponse>, Status> {
        let req = request.into_inner();
        let vms = self
            .hv
            .list_vms()
            .map_err(|e| Self::status_from_error("list_vms", e))?;
        let Some(vm) = vms
            .into_iter()
            .find(|v| v.id == req.vm_id || v.name == req.vm_id)
        else {
            return Err(Status::not_found(format!("VM not found: {}", req.vm_id)));
        };

        Ok(Response::new(proto::GetVmStatusResponse {
            vm_id: vm.id,
            status: Self::vm_state_to_string(vm.state),
            rosetta_enabled: vm.rosetta_enabled,
            shared_dirs: vm
                .shared_dirs
                .into_iter()
                .map(Self::proto_shared_dir)
                .collect(),
            disk_gb: vm.disk_gb,
        }))
    }

    async fn mount_virtio_fs(
        &self,
        request: Request<proto::MountVirtioFsRequest>,
    ) -> Result<Response<proto::MountVirtioFsResponse>, Status> {
        let req = request.into_inner();
        let vm_id = self.resolve_vm_id(&req.vm_id)?;
        let share = req
            .share
            .ok_or_else(|| Status::invalid_argument("share is required"))?;
        let share = Self::core_shared_dir(share);
        self.hv
            .mount_virtiofs(&vm_id, &share)
            .map_err(|e| Self::status_from_error("mount_virtiofs", e))?;
        Ok(Response::new(proto::MountVirtioFsResponse {}))
    }

    async fn unmount_virtio_fs(
        &self,
        request: Request<proto::UnmountVirtioFsRequest>,
    ) -> Result<Response<proto::UnmountVirtioFsResponse>, Status> {
        let req = request.into_inner();
        let vm_id = self.resolve_vm_id(&req.vm_id)?;
        self.hv
            .unmount_virtiofs(&vm_id, &req.tag)
            .map_err(|e| Self::status_from_error("unmount_virtiofs", e))?;
        Ok(Response::new(proto::UnmountVirtioFsResponse {}))
    }

    async fn list_virtio_fs_mounts(
        &self,
        request: Request<proto::ListVirtioFsMountsRequest>,
    ) -> Result<Response<proto::ListVirtioFsMountsResponse>, Status> {
        let req = request.into_inner();
        let vm_id = self.resolve_vm_id(&req.vm_id)?;
        let mounts = self
            .hv
            .list_virtiofs_mounts(&vm_id)
            .map_err(|e| Self::status_from_error("list_virtiofs_mounts", e))?;
        Ok(Response::new(proto::ListVirtioFsMountsResponse {
            mounts: mounts.into_iter().map(Self::proto_shared_dir).collect(),
        }))
    }
}
